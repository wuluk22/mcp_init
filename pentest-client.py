import requests
import json

# Configuration
KALI_IP = "192.168.1.100"  # Change to your Kali IP
BRIDGE_URL = f"http://{KALI_IP}:3001"
OLLAMA_URL = "http://localhost:11434/api/chat"

class MCPClient:
    def __init__(self, bridge_url):
        self.bridge_url = bridge_url
        self.session_id = None
    
    def init_session(self):
        """Initialize a new MCP session"""
        response = requests.post(f"{self.bridge_url}/session/init")
        data = response.json()
        self.session_id = data['sessionId']
        return data
    
    def list_tools(self):
        """List available tools"""
        response = requests.post(
            f"{self.bridge_url}/session/{self.session_id}/tools/list"
        )
        data = response.json()
        return data.get('result', {}).get('tools', [])
    
    def call_tool(self, name, arguments):
        """Call a tool"""
        response = requests.post(
            f"{self.bridge_url}/session/{self.session_id}/tools/call",
            json={'name': name, 'arguments': arguments},
            timeout=600
        )
        return response.json()
    
    def close_session(self):
        """Close the session"""
        if self.session_id:
            requests.post(f"{self.bridge_url}/session/{self.session_id}/close")

def format_tools_for_qwen(mcp_tools):
    """Convert MCP tools to Qwen format"""
    qwen_tools = []
    for tool in mcp_tools:
        qwen_tools.append({
            "type": "function",
            "function": {
                "name": tool['name'],
                "description": tool.get('description', ''),
                "parameters": tool.get('inputSchema', {})
            }
        })
    return qwen_tools

def chat_with_qwen(messages, tools):
    """Send request to Qwen"""
    payload = {
        "model": "qwen2.5:7b",
        "messages": messages,
        "tools": tools,
        "stream": False
    }
    
    response = requests.post(OLLAMA_URL, json=payload, timeout=60)
    return response.json()

def main():
    print("üîß Pentest Assistant - Initializing...")
    
    # Test connection
    try:
        response = requests.get(f"{BRIDGE_URL}/health", timeout=5)
        if response.status_code != 200:
            print(f"‚ùå Bridge not responding at {BRIDGE_URL}")
            return
    except:
        print(f"‚ùå Cannot connect to bridge at {BRIDGE_URL}")
        print("   Make sure the bridge is running on Kali:")
        print("   node mcp-http-bridge.js")
        return
    
    print(f"‚úÖ Connected to bridge at {BRIDGE_URL}")
    
    # Check Ollama
    try:
        requests.get("http://localhost:11434", timeout=2)
        print("‚úÖ Ollama is running")
    except:
        print("‚ùå Ollama not running. Start with: ollama serve")
        return
    
    # Initialize MCP session
    mcp = MCPClient(BRIDGE_URL)
    try:
        init_result = mcp.init_session()
        print(f"‚úÖ MCP session created: {mcp.session_id}")
        
        # List tools
        mcp_tools = mcp.list_tools()
        print(f"‚úÖ Available tools ({len(mcp_tools)}):")
        for tool in mcp_tools:
            print(f"   - {tool['name']}: {tool.get('description', '')[:50]}...")
        
        qwen_tools = format_tools_for_qwen(mcp_tools)
        messages = []
        
        print("\n" + "="*60)
        print("ü§ñ Pentest Assistant Ready (Qwen 2.5:7b + pentest-mcp)")
        print("="*60)
        print("Type your requests or 'exit' to quit")
        print("Example: 'Scan 192.168.1.1 with nmap'")
        print()
        
        while True:
            try:
                user_input = input("You: ").strip()
                
                if user_input.lower() in ['exit', 'quit', 'q']:
                    break
                
                if not user_input:
                    continue
                
                messages.append({"role": "user", "content": user_input})
                
                # Agentic loop
                for iteration in range(10):
                    response = chat_with_qwen(messages, qwen_tools)
                    assistant_msg = response.get('message', {})
                    messages.append(assistant_msg)
                    
                    # Check for tool calls
                    if 'tool_calls' in assistant_msg and assistant_msg['tool_calls']:
                        print(f"\nüî® Executing {len(assistant_msg['tool_calls'])} tool(s)...")
                        
                        for tool_call in assistant_msg['tool_calls']:
                            func = tool_call['function']
                            tool_name = func['name']
                            
                            if isinstance(func['arguments'], str):
                                tool_args = json.loads(func['arguments'])
                            else:
                                tool_args = func['arguments']
                            
                            print(f"\n  ‚Üí {tool_name}")
                            print(f"    {json.dumps(tool_args, indent=4)}")
                            
                            # Call tool via bridge
                            result = mcp.call_tool(tool_name, tool_args)
                            
                            # Extract content
                            if 'result' in result:
                                content = result['result'].get('content', [])
                                result_text = '\n'.join([
                                    item.get('text', str(item)) 
                                    for item in content
                                ])
                            else:
                                result_text = json.dumps(result)
                            
                            print(f"    ‚úì Done")
                            
                            messages.append({
                                "role": "tool",
                                "content": result_text
                            })
                        
                        continue
                    
                    # Show response
                    if 'content' in assistant_msg and assistant_msg['content']:
                        print(f"\nü§ñ {assistant_msg['content']}\n")
                    break
            
            except KeyboardInterrupt:
                print("\n\nExiting...")
                break
            except Exception as e:
                print(f"\n‚ùå Error: {e}\n")
        
    finally:
        mcp.close_session()
        print("üëã Session closed")

if __name__ == "__main__":
    main()
